### 基础知识的定义
- 能够满足业务开发的最小知识集合，例如：语言，框架，工具
- 熟悉工作流，从环境搭建->开发->上线

### 模块化
-   1. 将系统自上而下的分解为多个独立的模块，每个模块具备特定的功能和标准化的接口
-   2. 模块特征-高内聚低耦合
-   模块化技术实现的原理
-   1. 接口规范
-   2. 模块划分策略（按功能/按技术层级-前端-后端-桥接sdk）
-   3. 依赖管理
-   网络请求
-   1. 应用程序通过互联网向服务器发送数据请求
-   异步编程是一种代码执行模式：允许程序在等待耗时操作时不阻塞后续代码的执行
### react
- 基于组件的生命式UI框架
- ##### 基于组件
- react 基于组件的组合形式 --> 拆分若干颗粒度最较小的组件
- 声名式 是指 关注做什么，而不关注怎么做
-  css in js -> 是指样式代码直接写在 js 代码中
-  FPS frames per second
-  业务类开发绝大多数都是写页面： 1. 搭建静态页面  2. 给静态页面添加交互 。 ui设计稿拆分为哪些组件，这些组件又需要如何组合，
-  基于组件的架构模式，是重展示，重交互的最好选择
-  组件是内聚的，其内部既有逻辑又有状态还有视图，一个组件可以独立完成一件事情，使ui模块服用变得简单
-  组件与组件之间的数据流向是确定的- 自上往下 - 单向流动
-  组件的拆分--> 单一职责，与其它组件没有相互依赖
-  组件的依赖越少，设计的越好
-  宿主组件是直接由 ios/Android 原生平台实现的
-  社区库也有提供了宿主组件，也可以自行创建宿主组件 
-  #### 宿主组件--> 上层是 javaScript 底层实现是 原生视图 中间是有 react native 控制的
-  由组件组合而成的组件-> 复合组件
-  文字颜色只有Text 组件和 TextInput 组件具备
-  react native 中不存在`块级元素`和`行内元素的概念` <View> 和 <Text> 都是布局元素 它门都受 flex 布局的影响
-  在安卓中 文字默认有内边距且基于基线对其
-  页面状态的设计 -> 先看看页面中哪些数据是变化的，那些变化的数据可能是状态
-  react useState 对象引用类型state 更新陷阱  
``` jsx
  const [localState, setLocalState] = useState({ num: 0 })
       const   onPress=() => {
          localState.num++
          console.log('localState', localState)
          setLocalState(localState)
        }
        // 并不会触发 组件渲染 ，：在react 中 数据是不可变的 这个操作并没有变更 state 的对象引用所以不会触发组件更新
```
- 图片引用 require 函数的入参必须是字面常量 不能是变量
- 静态资源是独立于代码的，在打包后它会有一个注册信息 --> 宽高｜大小｜路径 代码打包编译之后静态资源会内置到 App 包之中 因此需要注册方便 加载和使用
- 图片在 require 引入的时候并不是引入的图片资源本身，而是引入图片资源的信息 Image 在获取到图片信息后才会根据规则去加载资源
- Image.resolveAssetSource 在运行时查看图片编译时注册的信息 Image 组件的底层是使用该方法来获取图片信息
- Android ｜ ios 安卓使用的是 fresco ios 是系统 内的 NSURLcache 采用内存+磁盘的中和缓存策略
- 内存缓存图片 超出限制后会自动释放 无限滚动的长列表场景非常适合图片的预加载
- base64 基于64个可见的字符表示二进制饿方式
- 图片的使用有4种 ： 1. 静态资源 assets 2. 网络图片 3.原生内置  4. base64 内嵌
- react native 动态更新框架
### C端产品用户体验很重要
 - TouchableWithoutFeedback 自定义用户操作反馈效果
 - 第三代点按组件 Pressable : Touchable -> Button -> Pressable
 - Pressable的样式可以接收一个函数跟据点按状态添加对应的样式
 - 开发时应当选第三代的点按组件
 - 开始事件响应 -> 结束事件响应 pressIn pressOut --->触发onPress PressIn --> onLongPressable 基于500毫秒计时做一些事件的封装
 - react native 中的盒模型概念来自于 web
 - margin 天生是透明的而且不可以设置颜色 
 - 点按区域仅在盒模型中的不透明区域
 - HitRect 点按可触发的区域 以原有盒模型的border为边界进行扩张
 - pressRetentionOffset 事件可保留区域以 border 作为计算的基准
 - 老版本的手机浏览器点击事件响应存在350ms 的延迟
### TextInput 输入框
- TextInput 是一个自带状态的宿主组件， 文字状态｜光标状态｜焦点状态 ｜ 联动键盘
- 组件的render就是函数组件的执行
- 在react 中存储跨域的两次render的可用方案是ref
- 非受控组件 用户输入->展示 都是在宿主层面进行展示的 
- 受控组件 -> 输入框的值始终都是由 state 驱动的
-  输入框的主力主要关注三件事 ： 1. 焦点控制 2. 输入框文字 3. 联动键盘 （良好的交互体验）
-  Fabric 同步渲染管线 js 与原生ui直接通信 ，消除了异步桥接的延迟。列表滚动等高频操作帧率提升
-  javaScript 即使死循环了，界面依旧能滚动，因为滚动操作是在UI线程完成的
### 列表
- 虚拟列表的底层支持 -> 动态渲染技术
- 滚动 在有限高度的容器内存放无限高度的内容
- ScrollView 一般不直接给其设置高度，而是给它的父组件设置高度
- VirtualizedList 底层使用的是 ScrollVIew
- 列表 与滚动的区别 -> 列表项可以单独的渲染或者卸载，滚动只能整体渲染或者卸载
- FlatList 列表项的高度全部由 onLayout 来计算，列表滚动是可能卡顿的，Layout 是在Ui线程中执行的
- 列表组件会通过唯一标识符服用原生视图 Android 上在列表项滚出屏幕的时候不会将其销毁而是会将其复用到新的列表项上
- FlatList 在滚动时复用了列表项而不是创建新的列表项  原生的 RecyclerView复用机制
- 通过更新索引控制渲染区域
- 宽高确定，子项类型可枚举
- 无限列表-> 通过前后索引来确定渲染区域
### react native 快速刷新
- 快速刷新的目的是即时反馈，热模块替换，-> 有数据通信-> 发送变更的视图，做增量发送 而不是整个发送，
- metro 服务 实现模块热替换的功能 
- Metro 服务的主要功能 模块热替换
- 模块热替换时保持状态不变的原理是--> 代理， 将就组件的状态引用指向新组件
- react native 的快速刷新是通过组件代理实现的复用原生视图的，函数在同一个上下文中执行，那么它访问到的外部变量是同一个
- 越小颗粒度组件的更新，越能保留越多的原状态和环境
- 广义的调试就是发现问题和解决问题的过程
- 监控系统和用户反馈系统
- 移动应用调试工具 Flipper