### 基础知识的定义
- 能够满足业务开发的最小知识集合，例如：语言，框架，工具
- 熟悉工作流，从环境搭建->开发->上线

### 模块化
-   1. 将系统自上而下的分解为多个独立的模块，每个模块具备特定的功能和标准化的接口
-   2. 模块特征-高内聚低耦合
-   模块化技术实现的原理
-   1. 接口规范
-   2. 模块划分策略（按功能/按技术层级-前端-后端-桥接sdk）
-   3. 依赖管理
-   网络请求
-   1. 应用程序通过互联网向服务器发送数据请求
-   异步编程是一种代码执行模式：允许程序在等待耗时操作时不阻塞后续代码的执行
### react
- 基于组件的生命式UI框架
- ##### 基于组件
- react 基于组件的组合形式 --> 拆分若干颗粒度最较小的组件
- 声名式 是指 关注做什么，而不关注怎么做
-  css in js -> 是指样式代码直接写在 js 代码中
-  FPS frames per second
-  业务类开发绝大多数都是写页面： 1. 搭建静态页面  2. 给静态页面添加交互 。 ui设计稿拆分为哪些组件，这些组件又需要如何组合，
-  基于组件的架构模式，是重展示，重交互的最好选择
-  组件是内聚的，其内部既有逻辑又有状态还有视图，一个组件可以独立完成一件事情，使ui模块服用变得简单
-  组件与组件之间的数据流向是确定的- 自上往下 - 单向流动
-  组件的拆分--> 单一职责，与其它组件没有相互依赖
-  组件的依赖越少，设计的越好
-  宿主组件是直接由 ios/Android 原生平台实现的
-  社区库也有提供了宿主组件，也可以自行创建宿主组件 
-  #### 宿主组件--> 上层是 javaScript 底层实现是 原生视图 中间是有 react native 控制的
-  由组件组合而成的组件-> 复合组件
-  文字颜色只有Text 组件和 TextInput 组件具备
-  react native 中不存在`块级元素`和`行内元素的概念` <View> 和 <Text> 都是布局元素 它门都受 flex 布局的影响
-  在安卓中 文字默认有内边距且基于基线对其
-  页面状态的设计 -> 先看看页面中哪些数据是变化的，那些变化的数据可能是状态
-  react useState 对象引用类型state 更新陷阱  
``` jsx
  const [localState, setLocalState] = useState({ num: 0 })
       const   onPress=() => {
          localState.num++
          console.log('localState', localState)
          setLocalState(localState)
        }
        // 并不会触发 组件渲染 ，：在react 中 数据是不可变的 这个操作并没有变更 state 的对象引用所以不会触发组件更新
```
- 图片引用 require 函数的入参必须是字面常量 不能是变量
- 静态资源是独立于代码的，在打包后它会有一个注册信息 --> 宽高｜大小｜路径 代码打包编译之后静态资源会内置到 App 包之中 因此需要注册方便 加载和使用
- 图片在 require 引入的时候并不是引入的图片资源本身，而是引入图片资源的信息 Image 在获取到图片信息后才会根据规则去加载资源
- Image.resolveAssetSource 在运行时查看图片编译时注册的信息 Image 组件的底层是使用该方法来获取图片信息
- Android ｜ ios 安卓使用的是 fresco ios 是系统 内的 NSURLcache 采用内存+磁盘的中和缓存策略
- 内存缓存图片 超出限制后会自动释放 无限滚动的长列表场景非常适合图片的预加载
- base64 基于64个可见的字符表示二进制饿方式
- 图片的使用有4种 ： 1. 静态资源 assets 2. 网络图片 3.原生内置  4. base64 内嵌
- react native 动态更新框架
### C端产品用户体验很重要
 - TouchableWithoutFeedback 自定义用户操作反馈效果
 - 第三代点按组件 Pressable : Touchable -> Button -> Pressable
 - Pressable的样式可以接收一个函数跟据点按状态添加对应的样式
 - 开发时应当选第三代的点按组件
 - 开始事件响应 -> 结束事件响应 pressIn pressOut --->触发onPress PressIn --> onLongPressable 基于500毫秒计时做一些事件的封装
 - react native 中的盒模型概念来自于 web
 - margin 天生是透明的而且不可以设置颜色 
 - 点按区域仅在盒模型中的不透明区域
 - HitRect 点按可触发的区域 以原有盒模型的border为边界进行扩张
 - pressRetentionOffset 事件可保留区域以 border 作为计算的基准
 - 老版本的手机浏览器点击事件响应存在350ms 的延迟
### TextInput 输入框
- TextInput 是一个自带状态的宿主组件， 文字状态｜光标状态｜焦点状态 ｜ 联动键盘
- 组件的render就是函数组件的执行
- 在react 中存储跨域的两次render的可用方案是ref
- 非受控组件 用户输入->展示 都是在宿主层面进行展示的 
- 受控组件 -> 输入框的值始终都是由 state 驱动的
-  输入框的主力主要关注三件事 ： 1. 焦点控制 2. 输入框文字 3. 联动键盘 （良好的交互体验）
-  Fabric 同步渲染管线 js 与原生ui直接通信 ，消除了异步桥接的延迟。列表滚动等高频操作帧率提升
-  javaScript 即使死循环了，界面依旧能滚动，因为滚动操作是在UI线程完成的
### 列表
- 虚拟列表的底层支持 -> 动态渲染技术
- 滚动 在有限高度的容器内存放无限高度的内容
- ScrollView 一般不直接给其设置高度，而是给它的父组件设置高度
- VirtualizedList 底层使用的是 ScrollVIew
- 列表 与滚动的区别 -> 列表项可以单独的渲染或者卸载，滚动只能整体渲染或者卸载
- FlatList 列表项的高度全部由 onLayout 来计算，列表滚动是可能卡顿的，Layout 是在Ui线程中执行的
- 列表组件会通过唯一标识符服用原生视图 Android 上在列表项滚出屏幕的时候不会将其销毁而是会将其复用到新的列表项上
- FlatList 在滚动时复用了列表项而不是创建新的列表项  原生的 RecyclerView复用机制
- 通过更新索引控制渲染区域
- 宽高确定，子项类型可枚举
- 无限列表-> 通过前后索引来确定渲染区域
### react native 快速刷新
- 快速刷新的目的是即时反馈，热模块替换，-> 有数据通信-> 发送变更的视图，做增量发送 而不是整个发送，
- metro 服务 实现模块热替换的功能 
- Metro 服务的主要功能 模块热替换
- 模块热替换时保持状态不变的原理是--> 代理， 将就组件的状态引用指向新组件
- react native 的快速刷新是通过组件代理实现的复用原生视图的，函数在同一个上下文中执行，那么它访问到的外部变量是同一个
- 越小颗粒度组件的更新，越能保留越多的原状态和环境
- 广义的调试就是发现问题和解决问题的过程
- 监控系统和用户反馈系统
- 移动应用调试工具 Flipper
### 开发
- 样式方案，推荐使用 自带的css in js StyleSheet ,
- 状态库 zustand 
- toC 应用大多数都是定制开发，没有依赖组件库
- react native 本省并没有提供路由解决方案
- react navigation 使用量比 react native navigation 大， 因此路由管理首选 react navigation 
- 动画使用 react-native-reanimated
### 知识的输入决定技术的输出-- 知识的输入决定技术输出

### 动画
- 动画的本质是连续切换的静态图， 每秒60帧，才能流畅，否则会掉帧
- 动画中的共享值 --> 类似于 state的状态值
- 动画有三个概念 ===> 1.共享值 2.衍生值 3.动画组件 state驱动和Reanimated 更新视图饿机制不一致
- 动画的共享值无专有的更新函数，它的值挂载在value 属性下
- 共享值的更新方式有两种 1. 带动画曲线， 2. 不带动画曲线  。 直接修改 value 值是不带动画曲线的，不会有动画效果 withTiming 启动基于时间的动画曲线
- state 和共享值 都是由数据驱动视图更新的
- react native 有两个常用的线程 1. javaScript 线程 2. ui线程   js 线程和 ui线程 是异步通信的
- Pressable 事件处理是在js 线程中处理的， 弊端： 拖拽类的动画容易卡顿
- reanimated 性能好的原因：避开了 javaScript 线程的瓶颈，在ui线程中创建了一个 javascript 虚拟机用于执行javaScript动画代码
- 金刚区 宫格布局，内容变 像变形金钢，所以取名为 金钢区
- 并不能在ui线程中调用 setState的方法
- 学习手势库的时候注意区分 ui线程和JavaScript 线程
- Gesture 真正强大的地方在于可以与 animated 配合一起使用
- 原生的动画是在js 线程中执行代码，然后与ui 线程进行异步通行 更新视图的， 受javaScript 线程瓶颈的限制，和有掉帧卡顿的现象 
- JavaScript 线程瓶颈 指的是啥： 1. 单一线程任务的阻塞， 2. 与原生线程的通信延迟
### Gesture 库的手势处理
-  Gesture 事件冒泡机制处理手势冲突
-  手势的生命周期 ，在生命周期内根据识别条件触发特定的回调函数
-  单视图冲突手势的处理方式  1. 竞态 2.优先级权重，排他  3. 聚合响应
-  react navigation Stack.Navigation -->收集导航页面 Stack.Screen 创建导航页面； 类似于数组和数组元素的关系
-  通过创建导航页面时定义的name进行跳转
-  在路由跳转的过程中 initialParams会和 跳转时的params 进行合并
### react native 监控系统  Sentry 
- Sentry 监控系统采集应用运行时的数据
- Sentry --实时的错误监控和性能分析Sdk ; 1. 异常捕获 2. 堆栈信息记录 3. 白屏 4. 崩溃信息记录 --- 原生和JS 
- 可以利用  @sentry/wizard@latest 自定义移动端调试工具
- react native 调试工具 Flipper 
### MMKV 
- 微信团队开发的跨进程的存储库 由C++开发 支持Android 和 ios 平台的高性能的键值存储 专为移动端设计
### 混合开发
- 混合开发是指一部分功能原生构建，一部分功能使用跨端框架构建
### react native 的优势
- 跨端
- 多端一致性
- 开发效率
### 混合开发的优势
- js部分更新快
- 发版不受限可随时更新
### 混合开发的劣势
- 性能不佳，渲染链路长
- 兼容性差
### react native AOT 提前编译技术
- 是将 js代码 提前编译为字节码文件- 在构建流程中集成编译步骤，
- AOT 的编译流程 JavaScript 源码 → Babel 转译 → Metro 打包 → Hermes 编译 → 原生二进制嵌入
- 构建时 hermes 引擎会将 js 文件转换为 .hbc 格式的二进制文件
- AOT 消除了运行时的解析开销
- 原生二进制嵌入也是发生在构建时 将.hbc 字节码文件打包到 apk的assets 目录 或 xcode 为其建立链接
  
### 混合开发的架构
1. 载体页面
2. 环境配置
3. 打包调试 
4. 原生开发对应的react native 组件
5. 图片处理 -> 数据库 等多线程的任务组件
6. 序列化与反序列化--> 主要是跨语言调用的 属性函数等转换为可传输的中间格式 底层更是使用c++ 实现了跨语言的统一接口
### 原生视图的生命周期
- 生命周期：组件1在创建-->更新--> 到销毁过程中 j
- js 不支持64位长类型只支持 32位的整形和 double 类型
- 广播模式---> 事件总线 ---> 发布者，订阅的设计（广播模式）
- 热更新--> 绕过应用商店对 app 进行更新 ： codePush 微软的，Pushy 阿里的（相对较好的开源热梗方案）
- 热更新主要的两个功能： 1.资源打包 2. 资源下发 
- 热更新难点在于大批量客户端管理
- CDN 上千个分布在全国的节点网络
### 拆包
- 按功能模块拆分，新旧代码可以一起工作，
- 延迟某些文件的加载
